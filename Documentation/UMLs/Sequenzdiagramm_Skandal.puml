@startuml
skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true
skinparam BoxPadding 10
skinparam ParticipantPadding 20
skinparam SequenceBoxBorderColor #888888

title Einzelner Simulationsschritt (mit Skandal)

actor "Benutzer" as User #LIGHTBLUE
participant "Dashboard\nController" as Dashboard #PLUM
participant "Simulation\nController" as SimController #CORAL
participant "Simulation\nEngine" as Engine #DEEPSKYBLUE
participant "Simulation\nState" as State #LIGHTBLUE
participant "Scandal\nScheduler" as Scheduler #LIGHTYELLOW
participant "Party\nRegistry" as PartyReg #LIGHTGREEN
participant "CSV\nLoader" as CSV #KHAKI
participant "Scandal\nImpact\nCalculator" as ImpactCalc #LIGHTYELLOW
participant "Voter\nBehavior" as VoterBehavior #LIGHTCORAL
participant "Voter\nPopulation" as VoterPop #PINK

== Schritt-Initiierung ==

User -> Dashboard : startet Simulation
activate Dashboard
Dashboard -> SimController : startSimulation()
activate SimController
SimController -> SimController : scheduleTask()
note right
  Erstellt periodischen
  Task für Simulation
end note

== Simulationsschritt-Ausführung ==

loop Jeder Tick

SimController -> Engine : runSimulationStep()
activate Engine

Engine -> State : incrementStep()
activate State
State --> Engine :
deactivate State

Engine -> State : getActiveScandals()
activate State
State --> Engine : List<ScandalEvent>
deactivate State

Engine -> Engine : Alte Skandale entfernen\n(älter als MAX_AGE_TICKS)

== Skandal-Erzeugung (falls ausgelöst) ==

Engine -> Scheduler : shouldScandalOccur()
activate Scheduler
Scheduler --> Engine : true
deactivate Scheduler

alt Skandal tritt auf UND mehr als 1 Partei

    Engine -> Engine : triggerNewScandal()
    activate Engine #FFAAAA

    Engine -> PartyReg : getParties()
    activate PartyReg
    PartyReg --> Engine : List<Party>
    deactivate PartyReg

    Engine -> Engine : Echte Parteien filtern\n(ohne "Unentschlossen")

    Engine -> Engine : Zielpartei zufällig wählen

    Engine -> CSV : getRandomScandal()
    activate CSV
    CSV --> Engine : Scandal
    deactivate CSV

    Engine -> Engine : ScandalEvent erstellen

    Engine -> State : addScandal(event)
    activate State
    State --> Engine :
    deactivate State

    Engine -> PartyReg : incrementScandalCount(party)
    activate PartyReg
    PartyReg --> Engine :
    deactivate PartyReg

    deactivate Engine

end

== Skandal-Auswirkungen berechnen ==

Engine -> ImpactCalc : calculateAcutePressure(scandals, parties, step)
activate ImpactCalc
ImpactCalc --> Engine : double[] acutePressures
deactivate ImpactCalc

Engine -> ImpactCalc : processRecovery(parties, populationSize)
activate ImpactCalc
ImpactCalc --> Engine :
deactivate ImpactCalc

== Wählerentscheidungen ==

Engine -> VoterBehavior : processVoterDecisions(population, parties, params, pressures, calculator)
activate VoterBehavior

VoterBehavior -> VoterPop : size()
activate VoterPop
VoterPop --> VoterBehavior : int voterCount
deactivate VoterPop

loop Für jeden Wähler

    VoterBehavior -> VoterPop : getPartyIndex(i)
    activate VoterPop
    VoterPop --> VoterBehavior : byte currentParty
    deactivate VoterPop

    VoterBehavior -> VoterPop : getVoterType(i)
    activate VoterPop
    VoterPop --> VoterBehavior : VoterType
    deactivate VoterPop

    VoterBehavior -> VoterPop : getLoyalty(i)
    activate VoterPop
    VoterPop --> VoterBehavior : float loyalty
    deactivate VoterPop

    VoterBehavior -> VoterBehavior : Entscheidung prüfen\n(Skandaldruck, Position, Loyalität)

    alt Wähler wechselt Partei
        VoterBehavior -> VoterPop : setPartyIndex(i, newParty)
        activate VoterPop
        VoterPop --> VoterBehavior :
        deactivate VoterPop

        VoterBehavior -> VoterBehavior : VoterTransition erstellen
    end

end

VoterBehavior --> Engine : List<VoterTransition>
deactivate VoterBehavior

== Unterstützerzahlen aktualisieren ==

Engine -> Engine : recalculateCounts()
activate Engine #AAFFAA

Engine -> VoterPop : size()
activate VoterPop
VoterPop --> Engine : int
deactivate VoterPop

loop Für jeden Wähler
    Engine -> VoterPop : getPartyIndex(i)
    activate VoterPop
    VoterPop --> Engine : byte partyIndex
    deactivate VoterPop

    Engine -> Engine : Zähler erhöhen
end

Engine -> PartyReg : updateSupporterCounts(counts)
activate PartyReg
PartyReg --> Engine :
deactivate PartyReg

deactivate Engine

== Rückgabe ==

Engine --> SimController : List<VoterTransition>
deactivate Engine

SimController -> Engine : getLastScandal()
activate Engine
Engine -> State : consumeLastScandal()
activate State
State --> Engine : ScandalEvent
deactivate State
Engine --> SimController : ScandalEvent
deactivate Engine

SimController -> Engine : getCurrentStep()
activate Engine
Engine -> State : getCurrentStep()
activate State
State --> Engine : int
deactivate State
Engine --> SimController : int
deactivate Engine

SimController -> Engine : getParties()
activate Engine
Engine -> PartyReg : getParties()
activate PartyReg
PartyReg --> Engine : List<Party>
deactivate PartyReg
Engine --> SimController : List<Party>
deactivate Engine

== UI-Update ==

SimController -> Dashboard : updateDashboard(parties, transitions, scandal, step)
activate Dashboard
Dashboard -> Dashboard : UI aktualisieren
Dashboard --> SimController :
deactivate Dashboard

end

deactivate SimController
deactivate Dashboard

@enduml
